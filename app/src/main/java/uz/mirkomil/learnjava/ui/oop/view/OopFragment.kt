package uz.mirkomil.learnjava.ui.oop.view

import android.view.View
import androidx.core.os.bundleOf
import androidx.recyclerview.widget.LinearLayoutManager
import uz.mirkomil.learnjava.R
import uz.mirkomil.learnjava.base.BaseFragment
import uz.mirkomil.learnjava.databinding.FragmentOopBinding
import uz.mirkomil.learnjava.model.LessonData
import uz.mirkomil.learnjava.repository.Repository
import uz.mirkomil.learnjava.ui.lesson.view.LessonFragment
import uz.mirkomil.learnjava.ui.oop.presenter.OopPresenter

class OopFragment : BaseFragment(R.layout.fragment_oop), OopView {

    lateinit var binding: FragmentOopBinding
    lateinit var adapter: OopAdapter
    lateinit var presenter: OopPresenter
    override fun onCreate(view: View) {
        binding = FragmentOopBinding.bind(view)
        adapter = OopAdapter()
        presenter  = OopPresenter(this, Repository.getRepositoryWithApiClient(requireContext()))
        presenter.saveLessons(getLessonsForLesson())
        binding.listOop.layoutManager = LinearLayoutManager(requireContext())
        binding.listOop.adapter = adapter
        adapter.swapdata(getLessonsForLesson())
        adapter.setOnclick {index, title ->
            val bundleLesson = bundleOf("lesson_id" to index+1, "subject_id" to 2, "title" to title)
            startFragment(LessonFragment(), isAnimate = true,bundle = bundleLesson )
        }
        binding.backBtnHelp.setOnClickListener {
            finish()
        }
    }

    fun getLessons(): ArrayList<String> {
        val data = ArrayList<String>()
        data.clear()
        for (i in 1..11) {
            data.add("$i - Dars")
        }
        return data
    }


    fun getLessonData(): ArrayList<LessonData> {
        val data = ArrayList<LessonData>()
        data.clear()
        data.add(LessonData(20,2,1, "OOP HAQIDA MALUMOTLAR","OOP: Qora quti yoxud dasturlash mag'zi\n" + "Salom, hammaga. OOP seriasidagi darslarimizni boshlasak ham bo'ladi. Deyarli barcha dastrurchilar va ko'pchilik dasturlashni o'rganayotganlar uchun «OOP» degan atama tanish va uni tushunish, tasavvur etish yetarlicha bilim hamda tajribani talab qiladi. Professional dasturchilar uchun bu «ajoib narsa, dasturlash mag'zi» bo'lsa, dasturlashga endi kirib kelayotganlar uchun esa «qora quti», talabalar uchun esa «domladan boshqa hech kim tushunmaydigan keraksiz mavzu» sifatida qaraladi. Aslida u nima?\n" + "\n" + "Ushbu seriadagi darslar kimlar uchun?\n" + "OOP ni tushunishni\n" + "xohlagan va dasturlashdan boshlang'ich bilimlarga ega bo'lgan\n" + "o'rganuvchilar uchun. Professional dasturchilardan esa ajoib va mazmunli\n" + "fikrlarini kutib qolamiz :).\n" + "\n" + "\n" + "Foydasi bormi?\n" + "Umuman olganda bu blogda foydasiz narsalar\n" + "yozilmaydi, agar bu narsa sizni qiziqtirsa demak albatta foydasi\n" + "bo'ladi. Bo'lajak dasturchi sifatida OOP ni tushunmaslik go'yoki\n" + "velosiped turganda piyoda yurishdek gap.\n" + "\n" + "\n" + "Talablar?\n" + "Mavzuga aloqador dastur kodlari Java tilida berib\n" + "boriladi, shuning uchun undan ozgina xabardor bo'lish kerak. Bundan\n" + "tashqari ilova qilingan havolalarni ham o'qib chiqish koni foyda. Har\n" + "bir dastur kodini o'z kompyuteringizda ishlatib ko'ring, o'zgartiring,\n" + "qo'shimchalar kiriting: takrorlash, sinab ko'rish va mustaqil\n" + "o'rganishga hech qanday o'quv metodi teng kela olmaydi :). Asosiy\n" + "terminlarni ingliz tilidagi varianti ham quyuq va kursiv shriftda berib boriladi, ular haqida google amakidan so'rab o'qib ko'ring. Demak birinchi darsimizni boshladik.\n" + "\n" + "\n" + "OOP nima?\n" + "OOP — ingliz tilidagi Object Orientated Programming\n" + "atamasining qisqartmasi, o'zbek tilimizda «Obyektga yo'naltirilgan\n" + "dasturlash» deb tarjima qilinadi. Dasturchilar orasida «OOP» sifatida\n" + "juda mashxur. Tarixi, kelib chiqishi va boshqa-boshqalar bilan batafsil wikida\n" + "o'qib oling (mavzuni tugatganimizdan so'ng). Talabalik yillarimizida\n" + "deyarli tushunib yetmaganmiz, «Dasturlash texnologiyalari», «OYDT» kabi\n" + "fanlarda tushunishga va tushuntirilishga rosa «harakat qilingan» mavzu\n" + ":). Afsus o'sha paytlarda bizda self-studying kuchli bo'lmagan yoki fan\n" + "o'qituvchilari o'zi endi o'rganayotgan mavzu bo'lgan. Keyinchalik ish va\n" + "qo'shimcha o'qish jarayonida amallab tushunib olganmiz. OOP ni iloji\n" + "boricha erta tushunish va tasavvur qilish dasturchini dasturlashga\n" + "bo'lgan qiziqishi va qarashlarini to'g'ri shakillantirar ekan. Shu\n" + "sababdan bugungi talabalar kechi bilan bakalavrni tugatguncha, normal\n" + "holda 2-kursni tugatguncha bu narsa bilan «oshna-og'ayni» bo'lib\n" + "olishlari kerak.\n" + "\n" + "\n" + "Domla tili bilan aytganda: \"OOP — dasturlash konsepsiyasi bo'lib,\n" + "bunda dasturlashdagi barcha narsa obyekt va obyektlar tizimi sifatida\n" + "talqin qilinadi va ...\", dexqonchasiga esa: \"OOP — obyektlarni obyektlar yordamida yaratish\", dasturchi tilida esa \"OOP — klass, metod, obyekt, obyektlar\". Bu turlicha gaplarning mantig'i bitta fikr \"OOP — dasturlashni obyektlar yordamida tashkil qilish usuli\" desak menimcha hech kim hafa bo'lmaydi. Iltimos, ushbu abzatsni qayta qayta o'qib chiqing toki nimanidir tushungunizcha.\n" + "\n" + "\n" + "Endi «Obyekt» atamasi ortida aynan nima yashiringanligiga to'xtalsak.\n" + "Obyekt — bu jism. Uni keng ma'noda «jismlar», «jarayon»,\n" + "«tizim»(sistema) deb ham tushunsak bo'ladi. Jism bu real hayotdagi\n" + "narsa, mavjudod, buyum va hodisa. Demak bu terminlarni hammasini bitta\n" + "so'z bilan — «obyekt» deb atasak. Ixtiyoriy obyekt — bir nechta\n" + "obyektlardan tashkil topgan. Ixtiyoriy jarayon yoki voqelikda ham\n" + "ko'plab obyektlar qatnashadi. Shu o'rinda «tizim» — bir necha obyektdan\n" + "tashkil topgan murakkab obyekt ekanligini etiborga olsak ixtiyoriy\n" + "obyektni tizim sifatida yoki tizimni obyekt sifatida qarashimiz mumkin.\n" + "Masalan real hayotdagi mashina — bu obyekt. Avtomashina ko'plab\n" + "obyektlar (dvigatel, korpus, akkumlyator, g'ildirak va boshqa ichki\n" + "mexanizmlar) dan tashkil topgan. Demak mashinani tizim sifatida qarasak\n" + "ham bo'ladi. O'z navbatida dvigatel ham ko'plab obyektlar (tsilindr,\n" + "porshen, svecha)dan tashkil topgan. Va hakazo, shu kabi ixtiyoriy obyekt\n" + "yoki tizimni mayda qismlarga bo'lib tashlasak bo'ladi. Bu real\n" + "hayotdagi obyektlardir.\n",null ))

        data.add(LessonData(21,2,2, "Java sinfining atributlari","Ikkita atributli \"Asosiy\" nomli sinf yaratamiz: x va y:\n" + "public class Main {\n" + "  int x = 5;\n" + "  int y = 3;\n" + "}\n" + "Xususiyatlarga kirish\n" + "Atributlarga sinf ob'ektini yaratish va nuqta sintaksisidan foydalanish orqali kirishingiz mumkin (.):\n" + "\n" + "Quyidagi misol myObj nomi bilan Main sinfining ob'ektini yaratadi. Qiymatini chiqarish uchun ob'ektdagi x atributidan foydalanamiz:\n" + "\n" + "Misol uchun\n" + "\"MyObj\" deb nomlangan ob'ekt yarating va x qiymatini ekranga chiqaring:\n" + "public class Main {\n" + "  int x = 5;\n" + "\n" + "  public static void main(String[] args) {\n" + "    Main myObj = new Main();\n" + "    System.out.println(myObj.x);\n" + "  }\n" + "}\n" + "Xususiyatlarni o'zgartirish\n" + "Siz shuningdek atribut qiymatlarini o'zgartirishingiz mumkin:\n" + "public class Main {\n" + "  int x;\n" + "\n" + "  public static void main(String[] args) {\n" + "    Main myObj = new Main();\n" + "    myObj.x = 40;\n" + "    System.out.println(myObj.x);\n" + "  }\n" + "}\n",null ))

        data.add(LessonData(22,2,3, "Javada constructor ","Konstruktor klass nomidagi funskiyadir. Javada konstruktorlar obyektni ishga tushurish uchun maxsus usuldir. Java konstruktor obyekt yaratish vaqtida chaqiriladi\n" + "Javada konstruktor yaratish qoidalari:\n" + "1.\tKonstruktor klass nomi bilan o’xshash bo’lishi kerak\n" + "2.\tKonstruktor noaniq ma’lumot turiga ega bo’lishi kerak\n" + "Konstruktorni ikkita turi mavjud:\n" + "1.\tArgumentsiz konstruktorlar\n" + "2.\tParametrlik konstruktorlar\n" + "Konstruktorga oddiy misol:\n" + "Bu misolda argumentsiz Bike1  konstruktor yaratildi. Obyekt yaratilishi vaqtida konstruktorni ishlatadi.\n" + "Source code\n" + "      \n" + "1.\tclass Bike1 {\n" + "2.\t \n" + "3.\tBike1() {\n" + "4.\tSystem.out.println(\"Bike is created\");\n" + "5.\t}\n" + "6.\t \n" + "7.\tpublic static void main(String args[]) {\n" + "8.\t \n" + "9.\tBike1 b = new Bike1();\n" + "10.\t \n" + "11.\t}\n" + "12.\t \n" + "13.\t}\n" + " \n" + "Majburiy konstruktorga misol\n" + "Source code\n" + "      \n" + "1.\tclass Student3 {\n" + "2.\t \n" + "3.\tint id;\n" + "4.\t \n" + "5.\tString name;\n" + "6.\t \n" + "7.\tvoid display() {\n" + "8.\tSystem.out.println(id+\" \"+name);\n" + "9.\t}\n" + "10.\t \n" + "11.\tpublic static void main(String args[]) {\n" + "12.\t \n" + "13.\tStudent3 s1=new Student3();\n" + "14.\t \n" + "15.\tStudent3 s2=new Student3();\n" + "16.\t \n" + "17.\ts1.display();\n" + "18.\t \n" + "19.\ts2.display();\n" + "20.\t \n" + "21.\t}\n" + "22.\t \n" + "23.\t}\n" + "ekranda:\n" + "0 null\n" + "0 null\n" + "Parametrga ega bo’lgan konstruktor\n" + "Source code\n" + "      \n" + "1.\tclass Student4 {\n" + "2.\t \n" + "3.\t    int id;\n" + "4.\t \n" + "5.\t    String name;\n" + "6.\t \n" + "7.\t    Student4(int i,String n) {\n" + "8.\t \n" + "9.\t    id = i;\n" + "10.\t \n" + "11.\t    name = n;\n" + "12.\t \n" + "13.\t    }\n" + "14.\t \n" + "15.\t    void display() {\n" + "16.\t       System.out.println(id+\" \"+name);\n" + "17.\t    }\n" + "18.\t \n" + "19.\t    public static void main(String args[]) {\n" + "20.\t \n" + "21.\t    Student4 s1 = new Student4(111,\"Akmal\");\n" + "22.\t \n" + "23.\t    Student4 s2 = new Student4(222,\"Zafar\");\n" + "24.\t \n" + "25.\t    s1.display();\n" + "26.\t \n" + "27.\t    s2.display();\n" + "28.\t \n" + "29.\t   }\n" + "30.\t \n" + "31.\t}\n" + "Ekrada:\n" + "111 Akmal\n" + "222 Zafar\n" + "Bu misolda parametrga ega bo’lgan konstruktor yaratildi.\n",null ))

        data.add(LessonData(23,2,4, "Javada  Encapsulation ","Enkapsulyatsiya OOPning to'rtta asosiy tushunchalaridan biridir. Qolgan uchtasi - meros, polimorfizm va mavhumlik.\n" + "\n" + "Java-da inkapsulatsiya - bu ma'lumotlar (o'zgaruvchilar) va ma'lumotlarga (usullarga) ta'sir qiluvchi kodni bir butunga birlashtirish mexanizmi. Inkapsulyatsiyada sinf o'zgaruvchilari boshqa sinflardan yashirin bo'ladi va ularga faqat joriy sinflari usullari orqali kirish mumkin. Shuning uchun, u ma'lumotlarni yashirish deb ham ataladi.\n" + "\n" + "Java-da kapsulaga erishish uchun -\n" + "\n" + "Sinf o'zgaruvchilarini xususiy deb e'lon qiling.\n" + "\n" + "O'zgaruvchan qiymatlarni o'zgartirish va ko'rish uchun umumiy to'plamni taqdim eting va usullarini oling.\n" + "\n" + "Quyida Java-da kapsulaga qanday erishishni ko'rsatadigan misol keltirilgan\n" + "\n" + "\n" + "Quyida Java-da kapsulaga qanday erishishni ko'rsatadigan misol keltirilgan\n" + "/* File name : EncapTest.java */\n" + "public class EncapTest {\n" + "   private String name;\n" + "   private String idNum;\n" + "   private int age;\n" + "\n" + "   public int getAge() {\n" + "      return age;\n" + "   }\n" + "\n" + "   public String getName() {\n" + "      return name;\n" + "   }\n" + "\n" + "   public String getIdNum() {\n" + "      return idNum;\n" + "   }\n" + "\n" + "   public void setAge( int newAge) {\n" + "      age = newAge;\n" + "   }\n" + "\n" + "   public void setName(String newName) {\n" + "      name = newName;\n" + "   }\n" + "\n" + "   public void setIdNum( String newId) {\n" + "      idNum = newId;\n" + "   }\n" + "}\n",null ))

        data.add(LessonData(24,2,5, "Java - Overriding ","Agar sinf o'z superklassidan usulni meros qilib oladigan bo'lsa, u holda yakuniy deb belgilanmagan bo'lsa, uni bekor qilish imkoniyati mavjud.\n" + "\n" + "Yo'q qilishning afzalligi quyidagicha: subklass turiga xos bo'lgan xatti-harakatni aniqlash qobiliyati, ya'ni subklass o'z talabidan kelib chiqqan holda ota-ona usulini amalga oshirishi mumkin.\n" + "\n" + "Ob'ektga yo'naltirilgan nuqtai nazardan, bekor qilish mavjud usulning funksionalligini bekor qilishni anglatadi.\n" + "\n" + "Misol\n" + "Keling, bir misolni ko'rib chiqaylik.\n" + "class Animal {\n" + "   public void move() {\n" + "      System.out.println(\"Animals can move\");\n" + "   }\n" + "}\n" + "\n" + "class Dog extends Animal {\n" + "   public void move() {\n" + "      System.out.println(\"Dogs can walk and run\");\n" + "   }\n" + "}\n" + "\n" + "public class TestDog {\n" + "\n" + "   public static void main(String args[]) {\n" + "      Animal a = new Animal();   // Animal reference and object\n" + "      Animal b = new Dog();   // Animal reference but Dog object\n" + "\n" + "      a.move();   // runs the method in Animal class\n" + "      b.move();   // runs the method in Dog class\n" + "   }\n" + "}\n" + "\n" + "Bu quyidagi natijani beradi -\n" + "\n" + "Chiqish\n" + "Hayvonlar harakatlanishi mumkin\n" + "Itlar yurishlari va chopishlari mumkin\n" + "Yuqoridagi misolda siz b ning Hayvonlarning bir turi bo'lsa ham, it sinfida ko'chirish usulini ishlatishini ko'rishingiz mumkin. Buning sababi: kompilyatsiya vaqtida tekshiruv mos yozuvlar turi bo'yicha amalga oshiriladi. Biroq, ish vaqtida JVM ob'ekt turini aniqlaydi va ushbu ob'ektga tegishli usulni ishlatadi.\n" + "\n" + "Shuning uchun, yuqoridagi misolda dastur to'g'ri kompilyatsiya qilinadi, chunki Animal sinfida usul harakati mavjud. Keyin, ish vaqtida u ushbu ob'ekt uchun maxsus usulni ishlatadi.\n" + "\n" + "Quyidagi misolni ko'rib chiqing -\n" + "\n" + "Misol\n" + "class Animal {\n" + "   public void move() {\n" + "      System.out.println(\"Animals can move\");\n" + "   }\n" + "}\n" + "\n" + "class Dog extends Animal {\n" + "   public void move() {\n" + "      System.out.println(\"Dogs can walk and run\");\n" + "   }\n" + "   public void bark() {\n" + "      System.out.println(\"Dogs can bark\");\n" + "   }\n" + "}\n" + "\n" + "public class TestDog {\n" + "\n" + "   public static void main(String args[]) {\n" + "      Animal a = new Animal();   // Animal reference and object\n" + "      Animal b = new Dog();   // Animal reference but Dog object\n" + "\n" + "      a.move();   // runs the method in Animal class\n" + "      b.move();   // runs the method in Dog class\n" + "      b.bark();\n" + "   }\n" + "}\n",null ))

        data.add(LessonData(25,2,6, "Javada Poliformism ","Polimorfizm orqali bir jarayonni turli yo'llar bilan tashkillashtirishimiz mumkin. Polimorfizm so'zi yunoncha ikki so'zning birikmasidan tashkil otpgan «poly» — Ko'p va «morphs» — formalar. Polimorfizm ham ko'p formalar degan ma'noni anglatadi.\n" + "Javada polimorfizmni ikki turi mavjud: programma kompilatsiya bo'layotgan vaqtda sodir bo'ladigan polimorfizm (compile time polymorphism, static polymorphism) va programma ishlab turgan vaqtda sodir bo'ladigan polimorfizm (runtime polymorphism, dynamic polymorphism). Javada polimorfizm metodlarni qayta yuklash (overload) va qayta yozish (override) bilan amalga oshiriladi.\n" + "Compile time polimorfizm\n" + "Agar metodni qayta yuklansa (overload) bu — compile time polimorfizmga misol bo'ladi. Ya'ni, agar class ichida bir xil nomli, ammo argumentlarning soni yoki argumentlarning ma'lumot tipi (yoki ikkalasi) farq qiladigan metodlar mavjud bo'lsa, bu compile time polimorfizm bo'ladi. Quyidagi misolga qarang:\n" + "class X\n" + "{\n" + "   void metodA(int num)\n" + "   {\n" + "       System.out.println (\"metodA:\" + num);\n" + "   }\n" + "   void metodA(int num1, int num2)\n" + "   {\n" + "       System.out.println (\"metodA:\" + num1 + \",\" + num2);\n" + "   }\n" + "   double metodA(double num) {\n" + "       System.out.println(\"metodA:\" + num);\n" + "       return num;\n" + "   }\n" + "}\n" + "\n" + "class Y\n" + "{\n" + "   public static void main (String args [])\n" + "   {\n" + "       X Obj = new X();\n" + "       double natija;\n" + "       Obj.metodA(20);\n" + "       Obj.metodA(20, 30);\n" + "       result = Obj.metodA(5.5);\n" + "       System.out.println(\"Javob:\" + natija);\n" + "   }\n" + "}\n" + "Natija:\n" + "metodA:20\n" + "metodA:20,30\n" + "metodA:5.5\n" + "Javob:5.5\n" + "Yuqoridagi misolda, X classning 3 ta metodi bor. Uchala metodlarning xam nomlari bir xil — metodA, ammo metodlarning argumentlarida farqlar mavjud. Kompilyatsiya vaqtida kompilyator metodga yuborilayotgan argumentlarning soni va ma'lumot tipiga qarab kerakli metodni tanlab oladi. Qaysi metodlarni chaqirish kompilatsiya vaqtida aniqlanishi tufayli ham bu polimorfizm turi Compile time polimorfizm deb nomlanadi.\n" + "Compile time polimorfizmni yana Static binding, Early binding deb ham ataladi.\n" + "Runtime polimorfizm\n" + "Dastlab casting, up-casting va down-casting tushunchalari bilan tanishib olaylik (Aslida, runtime polimorfizmni tushunish un faqat up-casting ni o'zini bilish yetadi, ammo men to'lqiroq yozdim). Obyektni bir toifadan boshqa toifaga o'tkazishgacasting deyiladi.\n" + "Agar ota classning obyekti bola class toifasga o'tkazilsa bu down-casting deyiladi. Misol:\n" + "Object satrObject = \"Bu shunchaki satr\"; // Object - ota class\n" + "String satrString = (String)ObyektSatr; // String - Object classning bola classi\n" + "Yuqoridagi misolda Object toifasidagi o'zgravchi (satrObject) String toifasiga o'zgartirilayapti. Bilamizki, Obyekt class barcha classlarning otasi hisoblanadi.\n" + "Agar bola classning obyekti ota class toifasga o'tkazilsa bu up-casting deyiladi. Misol:\n" + "String satrString = \"Bu shunchaki satr\"; \n" + "Object satrObject = (Object)satrString;\n" + "Agar ota classning o'zgaruvchisi bola class obyektini ko'rsatsa (xotiradagi adresini ko'rsatsa) ham up-casting deyiladi. Misol:\n" + "class A{}  \n" + "class B extends A{}\n" + "A a = new B(); //upcasting\n" + "Yuqoridagi misolda A class toifasidagi a o'zgaruvchi (reference variable) B bola classning obyektini ko'rsatadi (hotiradagi adresini ko'rsatadi).\n" + "Runtime polimorfizmda bola classdagi override qilingan metod, ota class toifasidagi o'zgaruvchi orqali chaqiriladi. Quyidagi misolga qarang:\n" + "class Chevrolet{  \n" + "  void run(){System.out.println(\"running\");}  \n" + "}  \n" + "class Malibu extends Chevrolet{  \n" + "  void run(){System.out.println(\"CHevrolet Malibu\");}  \n" + "  \n" + "  public static void main(String args[]){  \n" + "    Chevrolet ch = new Malibu();//upcasting  \n" + "    ch.run();  \n" + "  }  \n" + "}\n" + "Naija:\n" + "CHevrolet Malibu \n",null ))


        data.add(LessonData(26,2,7, "Javada packet(packages) ","To'plamlar Java-da nomlashdagi ziddiyatlarning oldini olish, kirishni boshqarish, sinflarni, interfeyslarni, sanoqlarni va izohlarni qidirishni / joylashtirishni va ulardan foydalanishni osonlashtirish va boshqalar uchun ishlatiladi.\n" + "\n" + "To'plamga kirishni himoya qilish va nomlar maydonini boshqarish bilan bog'liq turlarni (sinflar, interfeyslar, ro'yxatlar va izohlar) guruhlash sifatida ta'riflash mumkin.\n" + "\n" + "Java-da mavjud bo'lgan ba'zi paketlar -\n" + "\n" + "java.lang - asosiy sinflarni birlashtiradi\n" + "\n" + "java.io - kirish, chiqish funktsiyalari uchun sinflar ushbu paketga to'plangan\n" + "\n" + "Dasturchilar sinflar / interfeyslar va hokazolarni birlashtirish uchun o'z paketlarini belgilashlari mumkin. Siz amalga oshirgan tegishli sinflarni guruhlash yaxshi dastur hisoblanadi, shunda dasturchi sinflar, interfeyslar, sanoq va izohlarning bir-biriga bog'liqligini osonlikcha aniqlay oladi.\n" + "\n" + "To'plam yangi nomlar maydonini yaratganligi sababli, boshqa paketlardagi ismlar bilan hech qanday nom kelishmovchiligi bo'lmaydi. Paketlardan foydalanib, kirishni boshqarishni ta'minlash osonroq va tegishli sinflarni topish ham osonroq.\n" + "\n" + "To'plam yaratish\n" + "Paketni yaratishda siz paket uchun nom tanlashingiz va paketga qo'shmoqchi bo'lgan sinflar, interfeyslar, ro'yxatlar va izohlash turlarini o'z ichiga olgan har bir manba faylining yuqori qismiga ushbu nom bilan birga paket bayonotini kiritishingiz kerak.\n" + "\n" + "Paket bayonoti manba faylidagi birinchi qator bo'lishi kerak. Har bir manba faylida faqat bitta paketli bayonot bo'lishi mumkin va u faylning barcha turlariga tegishli.\n" + "\n" + "Agar paketli bayonot ishlatilmasa, u holda sinf, interfeyslar, ro'yxatlar va izohlash turlari joriy standart paketga joylashtiriladi.\n" + "\n" + "Java dasturlarini paketli bayonotlar bilan kompilyatsiya qilish uchun quyida ko'rsatilganidek -d parametridan foydalanishingiz kerak.\n" + "\n" + "javac -d Destination_folder file_name.java\n" + "\n" + "Keyin belgilangan manzilda berilgan paket nomiga ega papka yaratiladi va tuzilgan sinf fayllari o'sha papkaga joylashtiriladi.\n" + "\n" + "Misol\n" + "Hayvonlar deb nomlangan to'plamni yaratadigan misolni ko'rib chiqaylik. Paketlarning nomlarini kichik harflar bilan ishlatish, sinflar va interfeyslar nomlari bilan to'qnashuvlarning oldini olish uchun yaxshi amaliyotdir.\n" + "\n" + "Quyidagi to'plam misolida hayvonlar nomli interfeys mavjud -\n" + "/* File name : Animal.java */\n" + "package animals;\n" + "\n" + "interface Animal {\n" + "   public void eat();\n" + "   public void travel();\n" + "}\n" + "Keling, yuqoridagi interfeysni xuddi shu paket hayvonlarida qo'llaylik -\n" + "package animals;\n" + "/* File name : MammalInt.java */\n" + "\n" + "public class MammalInt implements Animal {\n" + "\n" + "   public void eat() {\n" + "      System.out.println(\"Mammal eats\");\n" + "   }\n" + "\n" + "   public void travel() {\n" + "      System.out.println(\"Mammal travels\");\n" + "   } \n" + "\n" + "   public int noOfLegs() {\n" + "      return 0;\n" + "   }\n" + "\n" + "   public static void main(String args[]) {\n" + "      MammalInt m = new MammalInt();\n" + "      m.eat();\n" + "      m.travel();\n" + "   }\n" + "} \n",null ))

        data.add(LessonData(27,2,8, "Java - Abstraction ","Lug'atga ko'ra, mavhumlik - bu voqealar emas, balki g'oyalar bilan ishlash sifati. Masalan, elektron pochta xabarlarini ko'rib chiqsangiz, elektron pochta xabarini yuborishingiz bilan nima sodir bo'lishi kabi murakkab tafsilotlar, sizning elektron pochta serveringiz foydalanadigan protokol foydalanuvchidan yashiringan. Shuning uchun elektron pochta xabarini yuborish uchun tarkibni yozishingiz, qabul qiluvchining manzilini eslatib qo'yishingiz va yuborish tugmachasini bosishingiz kerak.\n" + "\n" + "Xuddi shu tarzda Ob'ektga yo'naltirilgan dasturlashda abstraktsiya - bu amalga oshiruvchi tafsilotlarni foydalanuvchidan yashirish jarayoni, foydalanuvchiga faqat funksionallik ta'minlanadi. Boshqacha qilib aytganda, foydalanuvchi ob'ektni qanday bajarishi o'rniga nima qilgani haqida ma'lumotga ega bo'ladi.\n" + "\n" + "Java-da abstraktsiya mavhum sinflar va interfeyslar yordamida amalga oshiriladi.\n" + "\n" + "Mavhum sinf\n" + "Deklaratsiyasida mavhum kalit so'zni o'z ichiga olgan sinf mavhum sinf deb nomlanadi.\n" + "\n" + "Mavhum sinflar mavhum usullarni o'z ichiga olishi yoki o'z ichiga olishi mumkin, ya'ni tanasiz usullar (public void get ();)\n" + "\n" + "Ammo, agar sinfda kamida bitta mavhum usul mavjud bo'lsa, unda sinf mavhum deb e'lon qilinishi kerak.\n" + "\n" + "Agar sinf mavhum deb e'lon qilinsa, uni tasdiqlash mumkin emas.\n" + "\n" + "Abstrakt sinfdan foydalanish uchun siz uni boshqa sinfdan meros qilib olishingiz, undagi mavhum usullarni amalga oshirishingiz kerak.\n" + "\n" + "Agar siz mavhum sinfni meros qilib olsangiz, undagi barcha mavhum usullarni amalga oshirishingiz kerak.\n" + "\n" + "Misol\n" + "Ushbu bo'limda mavhum sinfga misol keltirilgan. Abstrakt sinf yaratish uchun faqat sinf deklaratsiyasida class kalit so'zidan oldin mavhum kalit so'zidan foydalaning\n" + "File name : Employee.java */\n" + "public abstract class Employee {\n" + "   private String name;\n" + "   private String address;\n" + "   private int number;\n" + "\n" + "   public Employee(String name, String address, int number) {\n" + "      System.out.println(\"Constructing an Employee\");\n" + "      this.name = name;\n" + "      this.address = address;\n" + "      this.number = number;\n" + "   }\n" + "   \n" + "   public double computePay() {\n" + "     System.out.println(\"Inside Employee computePay\");\n" + "     return 0.0;\n" + "   }\n" + "   \n" + "   public void mailCheck() {\n" + "      System.out.println(\"Mailing a check to \" + this.name + \" \" + this.address);\n" + "   }\n" + "\n" + "   public String toString() {\n" + "      return name + \" \" + address + \" \" + number;\n" + "   }\n" + "\n" + "   public String getName() {\n" + "      return name;\n" + "   }\n" + " \n" + "   public String getAddress() {\n" + "      return address;\n" + "   }\n" + "   \n" + "   public void setAddress(String newAddress) {\n" + "      address = newAddress;\n" + "   }\n" + " \n" + "   public int getNumber() {\n" + "      return number;\n" + "   }\n" + "}\n" + "Siz abstrakt usullardan tashqari Xodimlar sinfi Java-dagi oddiy sinf bilan bir xil ekanligini kuzatishingiz mumkin. Hozir sinf mavhum, ammo unda uchta maydon, ettita usul va bitta konstruktor mavjud.\n" + "\n" + "Endi siz xodimlar sinfini quyidagi tarzda tashkil etishga urinib ko'rishingiz mumkin –\n" + "/* File name : AbstractDemo.java */\n" + "public class AbstractDemo {\n" + "\n" + "   public static void main(String [] args) {\n" + "      /* Following is not allowed and would raise error */\n" + "      Employee e = new Employee(\"George W.\", \"Houston, TX\", 43);\n" + "      System.out.println(\"\\n Call mailCheck using Employee reference--\");\n" + "      e.mailCheck();\n" + "   }\n" + "}\n" + "Yuqoridagi sinfni kompilyatsiya qilganingizda, u sizga quyidagi xatoni beradi -\n" + "Employee.java:46: Employee is abstract; cannot be instantiated\n" + "      Employee e = new Employee(\"George W.\", \"Houston, TX\", 43);\n" + "                   ^\n" + "1 error\n",null ))

        data.add(LessonData(28,2,9, "Java - Fayllar and I/O ","Java.io to'plami Java-da kirish va chiqishni (I / U) bajarishingiz kerak bo'lgan deyarli barcha sinflarni o'z ichiga oladi. Ushbu oqimlarning barchasi kirish manbasini va chiqish manzilini anglatadi. Java.io paketidagi oqim ibtidoiy ma'lumotlar, ob'ekt, lokalizatsiya qilingan belgilar va boshqalar kabi ko'plab ma'lumotlarni qo'llab-quvvatlaydi.\n" + "Oqim ma'lumotlarning ketma-ketligi sifatida aniqlanishi mumkin.\n" + " Oqimlarning ikki turi mavjud -\n" + "InPutStream - InputStream manbadan ma'lumotlarni o'qish uchun ishlatiladi.\n" + "\n" + "OutPutStream - OutputStream ma'lumotlar manziliga yozish uchun ishlatiladi.\n" + "Java fayllar va tarmoqlar bilan bog'liq I / U uchun kuchli, ammo moslashuvchan qo'llab-quvvatlaydi, ammo ushbu qo'llanmada oqimlar va I / O bilan bog'liq juda oddiy funktsiyalar mavjud. Biz eng ko'p ishlatiladigan misollarni birma-bir ko'rib chiqamiz -\n" + "\n" + "Bayt oqimlari\n" + "Java bayt oqimlari 8 bitli baytlarni kiritish va chiqarishni amalga oshirish uchun ishlatiladi. Bayt oqimlari bilan bog'liq ko'plab sinflar mavjud bo'lsa-da, lekin ko'pincha ishlatiladigan sinflar FileInputStream va FileOutputStream. Quyida kirish faylini chiqish fayliga nusxalash uchun ushbu ikkita sinfdan foydalanadigan misol keltirilgan -\n" + "\n" + "Misol\n" + "import java.io.*;\n" + "public class CopyFile {\n" + "\n" + "   public static void main(String args[]) throws IOException {  \n" + "      FileInputStream in = null;\n" + "      FileOutputStream out = null;\n" + "\n" + "      try {\n" + "         in = new FileInputStream(\"input.txt\");\n" + "         out = new FileOutputStream(\"output.txt\");\n" + "         \n" + "         int c;\n" + "         while ((c = in.read()) != -1) {\n" + "            out.write(c);\n" + "         }\n" + "      }finally {\n" + "         if (in != null) {\n" + "            in.close();\n" + "         }\n" + "         if (out != null) {\n" + "            out.close();\n" + "         }\n" + "      }\n" + "   }\n" + "}\n" + "Endi quyidagi tarkibga ega input.txt faylini olamiz -\n" + "\n" + "Bu faylni nusxalash uchun sinov.\n" + "Keyingi qadam sifatida yuqoridagi dasturni kompilyatsiya qiling va uni bajaring, natijada input.txt-da biz bilan bir xil tarkibga ega output.txt fayli yaratiladi. Keling, yuqoridagi kodni CopyFile.java fayliga joylashtiramiz va quyidagilarni bajaramiz -\n" + "\n" + "\$ javac CopyFile.java\n" + "\$ java CopyFile\n" + "Belgilar oqimlari\n" + "Java bayt oqimlari 8 bitli baytlarni kiritish va chiqarishni amalga oshirish uchun ishlatiladi, Java Character oqimlari esa 16 bitli unikod uchun kirish va chiqishni amalga oshirish uchun ishlatiladi. Belgilar oqimlari bilan bog'liq ko'plab sinflar mavjud bo'lsa-da, lekin ko'pincha foydalaniladigan sinflar FileReader va FileWriter. Ichki FileReader FileInputStream-dan foydalangan bo'lsa-da, FileWriter FileOutputStream-dan foydalanadi, ammo bu erda asosiy farq shundaki, FileReader bir vaqtning o'zida ikkita bayt o'qiydi va FileWriter bir vaqtning o'zida ikkita bayt yozadi.\n" + "\n" + "Kirish faylini (unikod belgilariga ega) nusxasini chiqarish uchun ushbu ikki sinfdan foydalangan holda yuqoridagi misolni qayta yozishimiz mumkin -\n" + "\n" + "Misol\n" + "import java.io.*;\n" + "public class CopyFile {\n" + "\n" + "   public static void main(String args[]) throws IOException {\n" + "      FileReader in = null;\n" + "      FileWriter out = null;\n" + "\n" + "      try {\n" + "         in = new FileReader(\"input.txt\");\n" + "         out = new FileWriter(\"output.txt\");\n" + "         \n" + "         int c;\n" + "         while ((c = in.read()) != -1) {\n" + "            out.write(c);\n" + "         }\n" + "      }finally {\n" + "         if (in != null) {\n" + "            in.close();\n" + "         }\n" + "         if (out != null) {\n" + "            out.close();\n" + "         }\n" + "      }\n" + "   }\n" + "}\n",null ))

        data.add(LessonData(29,2,10, "Javada interfeyslar ","Javada interfeyslar orqali to'liq abstraktsiyani tashkillashtirish mumkin. Interfeys tarkibidagi metodlarning faqat nomlari bo'lishi mumkin, ularning tanasi bo'lishi mumkin emas. Shuningdek, Interfeys tarkibida ma'lumotlar bo'lishi ham mumkin.\n" + "Esda tuting: Java kompilyatori interfeys tarkibidagi metodlarga public va abstractkalit so'zlarni, interfeys tarkibidagi ma'lumotlarga esa public, static va final kalit so'zlarni qo'shadi.\n" + "Interfeyslarni classlarda foydalanish uchun implements kalit so'zi ishlatiladi. Quyidagi misolda, printable interfeysi bitta print() metodiga ega va ushbu metodning tanasi A class ichida yozilayapti.\n" + "interface printable{\n" + "void print();\n" + "}\t\t\t\n" + "\n" + "class A implements printable{\n" + "public void print(){System.out.println(\"Salom\");}\n" + "\n" + "public static void main(String args[]){\n" + "A obj = new A();\n" + "obj.print();\n" + "}\n" + "}\n" + "Bir class bir vatda bir nechta interfeyslarndan foydalanishi (implementation) mumkin. Quyidagi misolga qarang:\n" + "interface Printable{  \n" + "void print();  \n" + "}  \n" + "  \n" + "interface Showable{  \n" + "void show();  \n" + "}  \n" + "  \n" + "class A implements Printable,Showable{  \n" + "  \n" + "public void print(){System.out.println(\"Salom\");}  \n" + "public void show(){System.out.println(\"Hush kelibsiz\");}  \n" + "  \n" + "public static void main(String args[]){  \n" + "A obj = new A();  \n" + "obj.print();  \n" + "obj.show();  \n" + " }  \n" + "}\n" + "Quyidagi misolda class interfeydan foydalanadi, interfeys esa boshqa interfeysdan nasl oladi:\n" + "interface Printable{  \n" + "void print();  \n" + "}  \n" + "interface Showable extends Printable{  \n" + "void show();  \n" + "}  \n" + "class A implements Showable{  \n" + "  \n" + "public void print(){System.out.println(\"Salom\");}  \n" + "public void show(){System.out.println(\"Hush kelibsiz\");}  \n" + "  \n" + "public static void main(String args[]){  \n" + "A obj = new A();  \n" + "obj.print();  \n" + "obj.show();  \n" + " }  \n" + "}\n" + "Shunindek, bir interfyes tarkibida boshqa bir interyes bo'lishi ham mumkin:\n" + "interface Xat{  \n" + " void xatKeldi();  \n" + " interface xatHabar{  \n" + "   void xatHabarKeldi();  \n" + " }  \n" + "}\n",R.drawable.o10_1 ))

        data.add(LessonData(30,2,11, "Javada collectionlar ","Javada to’plamlar(collection’lar) framework bo’lib, u o’zida obyektlarni saqlaydi.\n" + "To’plamlarda barcha jarayonlar (saralash, qidirish, yozish, o’chirish  va h.k lar)ni oson amalga oshirish  mumkin.\n" + "To’plamlar bir necha interface’lardan tashkil topgan. Ular (Set, List, Queue, Deque etc.) va klass’lar (ArrayList, Vector, LinkedList, PriorityQueue, HashSet, LinkedHashSet, TreeSet va h.k).\n" + "To’plamlar obyektning alohida ko’rinishi.\n" + "To’plamlar frameworklar tuzilishi noma’lum bo’lgan obyekt guruhlarini o’zida yig’adi. To’plamlar ma’lumot yig’ishi bilan massivlarga o’xshab ketadi. Farqi massiv o’lchami statik To’plamlarniki esa dinamik, massiv bilan top’lamlarni qurilishi bir biridan tubdan faq qiladi va h.k.\n" + "To’plamlarning tuzilish sxemasi:\n",R.drawable.o11_1 ))

        return data
    }

    override fun showError(s: String) {
        toast(s)
    }

    fun getLessonsForLesson() : ArrayList<LessonData>{
        val data  = ArrayList<LessonData>()
        data.add(LessonData(0,0,0,"OOP HAQIDA MALUMOTLAR","",0))
        data.add(LessonData(0,0,0,"Java sinfining atributlari","",0))
        data.add(LessonData(0,0,0,"Javada constructor","",0))
        data.add(LessonData(0,0,0,"Javada  Encapsulation","",0))
        data.add(LessonData(0,0,0,"Java - Overriding","",0))
        data.add(LessonData(0,0,0,"Javada Poliformism","",0))
        data.add(LessonData(0,0,0,"Javada packet(packages)","",0))
        data.add(LessonData(0,0,0,"Java - Abstraction","",0))
        data.add(LessonData(0,0,0,"Java - Fayllar and I/O","",0))
        data.add(LessonData(0,0,0,"Javada interfeyslar","",0))
        data.add(LessonData(0,0,0,"Javada collectionlar","",0))

        return data
    }
}